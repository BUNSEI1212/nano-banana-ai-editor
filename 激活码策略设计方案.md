# 🔑 Nano Banana 激活码策略设计方案

## 🎯 全局唯一激活码验证系统

### 📊 新激活策略（全局唯一）

| 套餐类型 | 价格 | 额度 | 激活策略 | 使用场景 |
|---------|------|------|----------|----------|
| 🍌 尝鲜套餐 | ¥13.9 | 10次 | **全局唯一** | 体验推广，一次性使用 |
| 💎 基础套餐 | ¥69.9 | 100次 | **全局唯一** | 个人正式使用，设备绑定 |
| 🚀 高阶套餐 | ¥199.9 | 300次 | **全局唯一** | 专业用户使用，设备绑定 |

### 🔄 升级策略对比

| 特性 | 当前本地验证 | 新全局验证 | 升级影响 |
|------|-------------|-----------|----------|
| 激活码复用 | ✅ 同码多设备 | ❌ 一码一用 | 🔒 防止滥用 |
| 离线使用 | ✅ 完全离线 | ⚠️ 有限离线 | 📶 需要网络验证 |
| 安全性 | ⚠️ 本地可破解 | ✅ 服务器验证 | 🛡️ 大幅提升 |
| 用户体验 | ✅ 即时激活 | ⚠️ 需要网络 | 📱 轻微影响 |

## 🏗️ 中心化验证架构设计

### 🎯 核心架构模式
```
桌面应用 → 代理服务器 → 激活码数据库 → 设备绑定验证
    ↓           ↓              ↓
本地缓存 ← JWT Token ← 激活状态记录
```

### 🔧 技术栈选择
- **JWT认证**: fast-jwt库（性能最优，支持HS512算法）
- **数据库**: 扩展现有SQLite架构
- **API框架**: 基于现有Express服务器
- **缓存策略**: 内存LRU缓存 + 本地持久化

### 📊 数据库表结构设计

#### 激活码管理表
```sql
-- 激活码主表
CREATE TABLE IF NOT EXISTS activation_codes (
  code TEXT PRIMARY KEY,                    -- 激活码 (NB-XXXX-XXXX-XXXX)
  plan_type INTEGER NOT NULL,               -- 套餐类型 (1=尝鲜, 2=基础, 3=高阶)
  credits INTEGER NOT NULL,                 -- 额度数量
  price DECIMAL(10,2) NOT NULL,            -- 价格
  status TEXT DEFAULT 'unused',             -- 状态: unused, used, expired
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  used_at DATETIME NULL,                    -- 使用时间
  expires_at DATETIME NULL                  -- 过期时间（可选）
);

-- 激活记录表（设备绑定）
CREATE TABLE IF NOT EXISTS activations (
  id TEXT PRIMARY KEY,                      -- UUID
  activation_code TEXT NOT NULL,            -- 激活码
  device_id TEXT NOT NULL,                  -- 设备指纹
  device_info TEXT,                         -- 设备信息JSON
  user_identifier TEXT,                     -- 用户标识（可选）
  credits_granted INTEGER NOT NULL,         -- 授予的额度
  credits_used INTEGER DEFAULT 0,           -- 已使用额度
  activated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  last_used_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (activation_code) REFERENCES activation_codes (code),
  UNIQUE(activation_code, device_id)        -- 确保一个码在一个设备上只能激活一次
);

-- 使用记录表
CREATE TABLE IF NOT EXISTS activation_usage (
  id TEXT PRIMARY KEY,
  activation_id TEXT NOT NULL,
  operation_type TEXT NOT NULL,             -- 'generate' or 'edit'
  credits_consumed INTEGER DEFAULT 1,
  request_metadata TEXT,                    -- 请求元数据JSON
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (activation_id) REFERENCES activations (id)
);

-- 设备指纹表（防止设备伪造）
CREATE TABLE IF NOT EXISTS device_fingerprints (
  device_id TEXT PRIMARY KEY,
  hardware_info TEXT,                       -- 硬件信息JSON
  first_seen_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  last_seen_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  activation_count INTEGER DEFAULT 0       -- 该设备激活次数
);
```

### 🔗 API接口设计

#### 激活码验证接口
```javascript
// POST /api/activation/verify
{
  "activationCode": "NB-2S00-5678-EFGH",
  "deviceInfo": {
    "platform": "win32",
    "arch": "x64",
    "hostname": "USER-PC",
    "cpuModel": "Intel Core i7",
    "totalMemory": 16777216,
    "macAddress": "xx:xx:xx:xx:xx:xx"
  }
}

// Response
{
  "success": true,
  "token": "eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9...",
  "activation": {
    "id": "activation-uuid",
    "planType": 2,
    "creditsGranted": 100,
    "creditsRemaining": 100,
    "activatedAt": "2025-09-14T10:00:00Z"
  }
}
```

#### 激活状态查询接口
```javascript
// GET /api/activation/status
// Headers: Authorization: Bearer <token>

// Response
{
  "activated": true,
  "planType": 2,
  "creditsGranted": 100,
  "creditsUsed": 25,
  "creditsRemaining": 75,
  "deviceId": "device-fingerprint-hash",
  "activatedAt": "2025-09-14T10:00:00Z",
  "lastUsedAt": "2025-09-14T15:30:00Z"
}
```

#### 额度消费接口
```javascript
// POST /api/activation/consume
// Headers: Authorization: Bearer <token>
{
  "operation": "generate",
  "credits": 1,
  "metadata": {
    "prompt": "一只可爱的小猫",
    "requestId": "req-uuid"
  }
}
```

## �️ 桌面应用端集成方案

### 设备指纹生成（增强版）
```javascript
// 在activationManager.js中添加
const crypto = require('crypto');
const os = require('os');

class DeviceFingerprint {
  static generate() {
    const info = {
      platform: os.platform(),
      arch: os.arch(),
      hostname: os.hostname(),
      cpus: os.cpus()[0]?.model || 'unknown',
      totalmem: os.totalmem(),
      // 添加更多硬件特征
      networkInterfaces: this.getNetworkFingerprint()
    };

    const fingerprint = crypto
      .createHash('sha256')
      .update(JSON.stringify(info))
      .digest('hex');

    return {
      deviceId: fingerprint,
      deviceInfo: info
    };
  }

  static getNetworkFingerprint() {
    const interfaces = os.networkInterfaces();
    const macs = [];
    for (const name of Object.keys(interfaces)) {
      for (const iface of interfaces[name]) {
        if (!iface.internal && iface.mac !== '00:00:00:00:00:00') {
          macs.push(iface.mac);
        }
      }
    }
    return macs.sort();
  }
}
```

### 向后兼容的激活流程
```javascript
// 新的activateCode方法（保持向后兼容）
async activateCode(activationCode) {
  try {
    // 1. 首先进行本地格式验证
    const localValidation = this.validateCode(activationCode);
    if (!localValidation.valid) {
      return { success: false, error: localValidation.error };
    }

    // 2. 检查是否启用服务器验证
    const serverVerificationEnabled = process.env.ENABLE_SERVER_VERIFICATION === 'true';

    if (serverVerificationEnabled) {
      // 3. 新的服务器验证模式
      return await this.activateWithServerVerification(activationCode);
    } else {
      // 4. 保持现有的本地验证模式
      return await this.activateWithLocalVerification(activationCode);
    }
  } catch (error) {
    return {
      success: false,
      error: '激活过程中发生错误，请重试'
    };
  }
}
```

### 服务器验证实现
```javascript
async activateWithServerVerification(activationCode) {
  // 1. 生成设备指纹
  const { deviceId, deviceInfo } = DeviceFingerprint.generate();

  // 2. 向服务器验证激活码
  const proxyUrl = process.env.PROXY_ENDPOINT || 'http://localhost:3002';
  const response = await fetch(`${proxyUrl}/api/activation/verify`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      activationCode,
      deviceInfo
    })
  });

  if (!response.ok) {
    const error = await response.json();
    return { success: false, error: error.message };
  }

  const result = await response.json();

  // 3. 保存激活信息和JWT token
  const activationData = {
    isActivated: true,
    activationId: result.activation.id,
    activationCode,
    planType: result.activation.planType,
    creditsGranted: result.activation.creditsGranted,
    creditsRemaining: result.activation.creditsRemaining,
    deviceId,
    token: result.token,
    activatedAt: result.activation.activatedAt,
    lastSyncAt: new Date().toISOString(),
    serverMode: true  // 标记为服务器验证模式
  };

  await this.saveActivationData(activationData);

  return {
    success: true,
    data: activationData
  };
}

async activateWithLocalVerification(activationCode) {
  // 保持现有的本地验证逻辑完全不变
  const data = await this.loadActivationData();

  // 检查是否已经使用过此激活码
  const activationHistory = data.activationHistory || [];
  const alreadyUsed = activationHistory.find(record => record.code === activationCode);
  if (alreadyUsed) {
    return { success: false, error: '此激活码已经使用过' };
  }

  // 继续执行现有的本地激活逻辑...
  // （这里保持原有代码完全不变）
}
```

## 🌐 离线场景处理策略

### 离线验证机制
```javascript
class OfflineActivationManager {
  async checkActivationStatus() {
    const data = await this.loadActivationData();

    if (!data.isActivated) {
      return false;
    }

    // 如果是本地验证模式，直接返回
    if (!data.serverMode) {
      return this.checkLocalActivation(data);
    }

    // 服务器验证模式的离线处理
    if (this.isTokenExpired(data.token)) {
      // 尝试在线刷新
      const refreshed = await this.refreshActivationStatus();
      if (!refreshed) {
        // 离线模式：允许有限使用
        return this.handleOfflineMode(data);
      }
    }

    return true;
  }

  async handleOfflineMode(data) {
    const offlineGracePeriod = 7 * 24 * 60 * 60 * 1000; // 7天
    const lastSync = new Date(data.lastSyncAt);
    const now = new Date();

    if (now - lastSync > offlineGracePeriod) {
      return false; // 超过离线宽限期
    }

    // 离线模式下允许使用，但限制功能
    return {
      offline: true,
      creditsRemaining: Math.min(data.creditsRemaining, 10), // 离线最多10次
      message: '当前为离线模式，功能受限'
    };
  }
}
```

## �️ 安全性增强措施

### JWT Token配置
```javascript
// 使用fast-jwt的高性能配置
const { createSigner, createVerifier } = require('fast-jwt');

const tokenSigner = createSigner({
  key: process.env.ACTIVATION_JWT_SECRET,
  algorithm: 'HS512',
  expiresIn: '30d'
});

const tokenVerifier = createVerifier({
  key: process.env.ACTIVATION_JWT_SECRET,
  algorithms: ['HS512'],
  cache: true,
  errorCacheTTL: 60000 // 缓存错误1分钟
});
```

### 防重放攻击
```javascript
// 在激活验证中添加时间戳和随机数
const activationRequest = {
  activationCode,
  deviceInfo,
  timestamp: Date.now(),
  nonce: crypto.randomBytes(16).toString('hex')
};

// 服务器端验证时间戳（5分钟内有效）
const requestAge = Date.now() - request.timestamp;
if (requestAge > 5 * 60 * 1000) {
  throw new Error('请求已过期');
}
```

### 设备绑定验证
```javascript
// 服务器端设备验证逻辑
async function validateDeviceBinding(activationCode, deviceId) {
  const existingActivation = await db.get(
    'SELECT * FROM activations WHERE activation_code = ?',
    [activationCode]
  );

  if (existingActivation) {
    if (existingActivation.device_id !== deviceId) {
      throw new Error('此激活码已在其他设备上使用');
    }
  }

  return true;
}
```

## �🚀 实施阶段规划

### 阶段1：基础架构（1-2天）⚠️ 影响现有功能
**任务：**
1. ✅ 扩展gemini-proxy数据库表结构
2. ✅ 实现基础的激活码验证API
3. ✅ 添加JWT token生成和验证
4. ⚠️ 修改activationManager.js支持双模式

**影响评估：**
- 🟢 **无影响**：现有用户继续使用本地验证
- 🟡 **轻微影响**：需要重新打包应用
- 🔴 **需要测试**：确保向后兼容性

**回滚方案：**
```javascript
// 环境变量控制，默认关闭服务器验证
process.env.ENABLE_SERVER_VERIFICATION = 'false'
```

### 阶段2：桌面应用集成（2-3天）⚠️ 需要重新分发
**任务：**
1. ⚠️ 修改activationManager.js支持服务器验证
2. ✅ 实现设备指纹生成（纯新增）
3. ✅ 添加离线模式处理（纯新增）
4. ⚠️ 更新激活界面提示

**影响评估：**
- 🟢 **无影响**：现有激活用户正常使用
- 🟡 **需要更新**：新用户需要下载新版本
- 🔴 **需要测试**：全面测试激活流程

**回滚方案：**
- 保留旧版本安装包
- 服务器端可以降级到本地验证模式

### 阶段3：安全性增强（1-2天）✅ 纯新增功能
**任务：**
1. ✅ 添加防重放攻击机制（纯新增）
2. ✅ 实现设备绑定验证（纯新增）
3. ✅ 添加异常检测和日志（纯新增）
4. ✅ 性能优化和缓存调优（纯新增）

**影响评估：**
- 🟢 **无影响**：所有功能都是新增
- 🟢 **向后兼容**：不影响现有用户

### 阶段4：测试和优化（1-2天）✅ 验证阶段
**任务：**
1. ✅ 全面测试各种场景
2. ✅ 性能基准测试
3. ✅ 错误处理完善
4. ✅ 文档更新

## 🎯 推荐实施策略

### 渐进式升级方案
```javascript
// 第一步：部署服务器端（不影响现有用户）
// 第二步：发布新版本桌面应用（默认本地验证）
// 第三步：逐步启用服务器验证（通过环境变量控制）
// 第四步：全面切换到服务器验证

// 配置示例
const config = {
  // 开发环境：本地验证
  development: { serverVerification: false },
  // 测试环境：服务器验证
  testing: { serverVerification: true },
  // 生产环境：根据需要切换
  production: { serverVerification: process.env.ENABLE_SERVER_VERIFICATION === 'true' }
};
```

### 用户迁移策略
1. **现有用户**：继续使用本地验证，不受影响
2. **新用户**：默认使用服务器验证
3. **逐步迁移**：通过更新提示引导用户升级
4. **完全切换**：在确保稳定后全面启用

**🎉 这个方案既保证了激活码的全局唯一性，又最大程度保护了现有用户的体验！**
