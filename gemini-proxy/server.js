const express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst rateLimit = require('express-rate-limit');\nconst dotenv = require('dotenv');\nconst path = require('path');\n\n// Load environment variables\ndotenv.config();\n\nconst app = express();\nconst PORT = process.env.PORT || 3001;\n\n// Import modules\nconst authMiddleware = require('./middleware/auth');\nconst quotaMiddleware = require('./middleware/quota');\nconst geminiService = require('./services/gemini');\nconst dbService = require('./services/database');\nconst logger = require('./utils/logger');\n\n// Import activation routes\nconst activationRoutes = require('./routes/activation');\n\n// Initialize database\ndbService.init();\n\n// Security middleware\napp.use(helmet());\napp.use(cors({\n  origin: process.env.NODE_ENV === 'production' \n    ? ['http://localhost:3000', 'https://your-domain.com'] \n    : true,\n  credentials: true\n}));\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 15 * 60 * 1000, // 15 minutes\n  max: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS) || 100,\n  message: {\n    error: 'Too many requests from this IP, please try again later.',\n    retryAfter: Math.ceil((parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 15 * 60 * 1000) / 1000)\n  },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\napp.use(limiter);\napp.use(express.json({ limit: '50mb' }));\napp.use(express.urlencoded({ extended: true, limit: '50mb' }));\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n  res.json({\n    status: 'ok',\n    timestamp: new Date().toISOString(),\n    service: 'gemini-proxy'\n  });\n});\n\n// API Keys status endpoint\napp.get('/api/keys/status', (req, res) => {\n  try {\n    const keyStats = geminiService.getApiKeyStats();\n\n    res.json({\n      success: true,\n      timestamp: new Date().toISOString(),\n      keyStats: keyStats\n    });\n  } catch (error) {\n    logger.error('Failed to get API key stats:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to retrieve API key statistics'\n    });\n  }\n});\n\n// Mount activation routes\napp.use('/api/activation', activationRoutes);\n\n// OAuth callback endpoint\napp.post('/auth/callback', async (req, res) => {\n  try {\n    const { code, state } = req.body;\n\n    if (!code || !state) {\n      return res.status(400).json({ error: 'Missing code or state parameter' });\n    }\n\n    // Exchange authorization code for access token\n    const tokenResponse = await fetch(`${process.env.CASDOOR_ENDPOINT}/api/login/oauth/access_token`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        grant_type: 'authorization_code',\n        client_id: process.env.CASDOOR_CLIENT_ID,\n        client_secret: process.env.CASDOOR_CLIENT_SECRET,\n        code: code,\n        redirect_uri: `${process.env.FRONTEND_URL}/oauth/callback`\n      })\n    });\n\n    if (!tokenResponse.ok) {\n      const errorText = await tokenResponse.text();\n      logger.error('Token exchange failed:', errorText);\n      return res.status(400).json({ error: 'Failed to exchange authorization code' });\n    }\n\n    const tokenData = await tokenResponse.json();\n\n    // Get user info using the access token\n    const userResponse = await fetch(`${process.env.CASDOOR_ENDPOINT}/api/get-account`, {\n      headers: {\n        'Authorization': `Bearer ${tokenData.access_token}`\n      }\n    });\n\n    if (!userResponse.ok) {\n      logger.error('Failed to get user info');\n      return res.status(400).json({ error: 'Failed to get user information' });\n    }\n\n    const userData = await userResponse.json();\n\n    // Store user info in database if needed\n    await dbService.upsertUser({\n      id: userData.name,\n      email: userData.email,\n      displayName: userData.displayName,\n      avatar: userData.avatar\n    });\n\n    res.json({\n      token: tokenData.access_token,\n      user: {\n        id: userData.name,\n        email: userData.email,\n        displayName: userData.displayName,\n        avatar: userData.avatar\n      }\n    });\n  } catch (error) {\n    logger.error('OAuth callback error:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\n// Authentication endpoint\napp.get('/auth/me', authMiddleware, async (req, res) => {\n  try {\n    const userId = req.user.sub;\n    const userInfo = await dbService.getUserInfo(userId);\n    const usage = await dbService.getUserUsage(userId);\n    \n    res.json({\n      userId: userId,\n      email: req.user.email,\n      roles: req.user.roles || [],\n      plan: userInfo.plan || 'free',\n      usage: {\n        genCount: usage.genCount || 0,\n        editCount: usage.editCount || 0,\n        creditsRemaining: Math.max(0, (userInfo.monthlyCredits || 0) - (usage.creditsUsed || 0))\n      }\n    });\n  } catch (error) {\n    logger.error('Error getting user info:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\n// Gemini generate endpoint\napp.post('/api/generate', authMiddleware, quotaMiddleware, async (req, res) => {\n  try {\n    const { prompt, refImages = [], options = {} } = req.body;\n    const userId = req.user.sub;\n    const requestId = require('uuid').v4();\n\n    // Validate request\n    if (!prompt) {\n      return res.status(400).json({ error: 'Prompt is required' });\n    }\n\n    logger.info(`Generate request from user ${userId}:`, { requestId, prompt: prompt.substring(0, 100) });\n\n    // Call Gemini API\n    const result = await geminiService.generateImage({\n      prompt,\n      refImages,\n      options,\n      requestId\n    });\n\n    // Record usage\n    await dbService.recordUsage({\n      userId,\n      type: 'generate',\n      units: 1,\n      requestId,\n      metadata: { prompt: prompt.substring(0, 200) }\n    });\n\n    res.json({\n      success: true,\n      requestId,\n      result\n    });\n\n  } catch (error) {\n    logger.error('Generate error:', error);\n    \n    if (error.message.includes('quota')) {\n      return res.status(429).json({ \n        error: 'Quota exceeded', \n        message: 'Please upgrade your plan or wait for quota reset' \n      });\n    }\n    \n    res.status(500).json({ error: 'Generation failed' });\n  }\n});\n\n// Gemini edit endpoint\napp.post('/api/edit', authMiddleware, quotaMiddleware, async (req, res) => {\n  try {\n    const { imageId, mask, instruction, refImages = [] } = req.body;\n    const userId = req.user.sub;\n    const requestId = require('uuid').v4();\n\n    // Validate request\n    if (!imageId || !instruction) {\n      return res.status(400).json({ error: 'ImageId and instruction are required' });\n    }\n\n    logger.info(`Edit request from user ${userId}:`, { requestId, imageId, instruction: instruction.substring(0, 100) });\n\n    // Call Gemini API\n    const result = await geminiService.editImage({\n      imageId,\n      mask,\n      instruction,\n      refImages,\n      requestId\n    });\n\n    // Record usage\n    await dbService.recordUsage({\n      userId,\n      type: 'edit',\n      units: 1,\n      requestId,\n      metadata: { imageId, instruction: instruction.substring(0, 200) }\n    });\n\n    // Format response to match expected structure\n    const response = {\n      success: true,\n      requestId,\n      result: {\n        images: result.images || [],\n        content: result.images ? result.images.map(img => ({ inlineData: { data: img } })) : [],\n        finishReason: result.finishReason,\n        safetyRatings: result.safetyRatings,\n        metadata: result.metadata\n      }\n    };\n\n    res.json(response);\n\n  } catch (error) {\n    logger.error('Edit error:', error);\n    \n    if (error.message.includes('quota')) {\n      return res.status(429).json({ \n        error: 'Quota exceeded', \n        message: 'Please upgrade your plan or wait for quota reset' \n      });\n    }\n    \n    res.status(500).json({ error: 'Edit failed' });\n  }\n});\n\n// Billing endpoints (placeholder for Casdoor integration)\napp.get('/billing/plans', (req, res) => {\n  res.json({\n    plans: [\n      {\n        id: 'free',\n        name: 'Free',\n        price: 0,\n        currency: 'CNY',\n        interval: 'month',\n        features: {\n          monthlyCredits: 3,\n          maxConcurrency: 1\n        },\n        description: '免费用户每月3次图像生成额度'\n      },\n      {\n        id: 'nano-banana-credits',\n        name: 'Experience Pack',\n        price: 13.9,\n        currency: 'CNY',\n        interval: 'one-time',\n        features: {\n          monthlyCredits: 20,\n          maxConcurrency: 2\n        },\n        description: '体验套餐，一次性购买获得20次图像生成额度',\n        popular: true\n      },\n      {\n        id: 'lite-plan',\n        name: 'Lite',\n        price: 69.9,\n        currency: 'CNY',\n        interval: 'month',\n        features: {\n          monthlyCredits: 100,\n          maxConcurrency: 2\n        },\n        description: '轻量套餐，每月100次图像生成额度'\n      },\n      {\n        id: 'pro-plan',\n        name: 'Pro',\n        price: 199.9,\n        currency: 'CNY',\n        interval: 'month',\n        features: {\n          monthlyCredits: 500,\n          maxConcurrency: 5\n        },\n        description: '专业套餐，每月500次图像生成额度，支持更高并发'\n      }\n    ]\n  });\n});\n\napp.get('/billing/subscription', authMiddleware, async (req, res) => {\n  try {\n    const userId = req.user.sub;\n    const subscription = await dbService.getUserSubscription(userId);\n    res.json(subscription);\n  } catch (error) {\n    logger.error('Error getting subscription:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\n// Payment webhook endpoint for Casdoor\napp.post('/billing/webhook/payment', async (req, res) => {\n  try {\n    const { userId, planId, paymentId, status, provider } = req.body;\n\n    logger.info('Payment webhook received:', { userId, planId, paymentId, status, provider });\n\n    if (status === 'paid' || status === 'completed') {\n      // Activate subscription for the user\n      const subscription = await dbService.activateSubscription(userId, planId, {\n        paymentId,\n        provider\n      });\n\n      logger.info('Subscription activated:', subscription);\n\n      res.json({\n        success: true,\n        message: 'Subscription activated successfully',\n        subscription\n      });\n    } else {\n      logger.warn('Payment not completed:', { userId, planId, status });\n      res.json({\n        success: false,\n        message: 'Payment not completed'\n      });\n    }\n  } catch (error) {\n    logger.error('Payment webhook error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to process payment webhook'\n    });\n  }\n});\n\n// Manual subscription activation endpoint (for testing)\napp.post('/billing/activate-subscription', authMiddleware, async (req, res) => {\n  try {\n    const userId = req.user.sub;\n    const { planId } = req.body;\n\n    if (!planId) {\n      return res.status(400).json({ error: 'Plan ID is required' });\n    }\n\n    logger.info('Manual subscription activation:', { userId, planId });\n\n    const subscription = await dbService.activateSubscription(userId, planId, {\n      provider: 'manual'\n    });\n\n    res.json({\n      success: true,\n      message: 'Subscription activated successfully',\n      subscription\n    });\n  } catch (error) {\n    logger.error('Manual subscription activation error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to activate subscription'\n    });\n  }\n});\n\n// Subscription sync endpoint\napp.post('/billing/sync-subscription', authMiddleware, async (req, res) => {\n  try {\n    const userId = req.user.sub;\n    const { subscriptionData } = req.body;\n\n    logger.info('Syncing subscription from Casdoor:', { userId, subscriptionData });\n\n    await dbService.syncSubscriptionFromCasdoor(userId, subscriptionData);\n\n    res.json({\n      success: true,\n      message: 'Subscription synced successfully'\n    });\n  } catch (error) {\n    logger.error('Subscription sync error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to sync subscription'\n    });\n  }\n});\n\n// Periodic task to check and expire subscriptions\nconst checkExpiredSubscriptions = async () => {\n  try {\n    const expiredSubs = await dbService.getExpiredSubscriptions();\n\n    for (const sub of expiredSubs) {\n      await dbService.expireSubscription(sub.id);\n      logger.info('Expired subscription:', {\n        subscriptionId: sub.id,\n        userId: sub.casdoor_user_id,\n        planCode: sub.plan_code\n      });\n    }\n\n    if (expiredSubs.length > 0) {\n      logger.info(`Processed ${expiredSubs.length} expired subscriptions`);\n    }\n  } catch (error) {\n    logger.error('Error checking expired subscriptions:', error);\n  }\n};\n\n// Run subscription check every hour\nsetInterval(checkExpiredSubscriptions, 60 * 60 * 1000);\n\n// Error handling middleware\napp.use((error, req, res, next) => {\n  logger.error('Unhandled error:', error);\n  res.status(500).json({ error: 'Internal server error' });\n});\n\n// 404 handler\napp.use((req, res) => {\n  res.status(404).json({ error: 'Endpoint not found' });\n});\n\n// Start server\napp.listen(PORT, () => {\n  logger.info(`Gemini Proxy Service running on port ${PORT}`);\n  logger.info(`Environment: ${process.env.NODE_ENV}`);\n});\n\n// Graceful shutdown\nprocess.on('SIGTERM', () => {\n  logger.info('SIGTERM received, shutting down gracefully');\n  process.exit(0);\n});\n\nprocess.on('SIGINT', () => {\n  logger.info('SIGINT received, shutting down gracefully');\n  process.exit(0);\n});\n"