const axios = require('axios');\nconst logger = require('../utils/logger');\nconst ApiKeyManager = require('./apiKeyManager');\n\nclass GeminiService {\n  constructor() {\n    this.apiKeyManager = new ApiKeyManager();\n    this.useRelayApi = process.env.USE_RELAY_API === 'true';\n\n    if (this.useRelayApi) {\n      // ä¸­è½¬APIé…ç½®\n      this.baseUrl = process.env.RELAY_API_URL || 'https://hiapi.online/v1';\n      this.isOpenAICompatible = true;\n      logger.info('ğŸ”„ Initialized with Relay API (OpenAI-compatible)');\n    } else {\n      // ä¼ ç»Ÿç›´è¿APIé…ç½®\n      this.baseUrl = process.env.GEMINI_API_URL || 'https://generativelanguage.googleapis.com/v1beta';\n      this.isOpenAICompatible = false;\n      logger.info('ğŸ”— Initialized with Direct Gemini API');\n    }\n\n    this.client = axios.create({\n      baseURL: this.baseUrl,\n      timeout: 60000, // 60 seconds timeout\n      headers: {\n        'Content-Type': 'application/json',\n      }\n    });\n  }\n\n  async generateImage({ prompt, refImages = [], options = {}, requestId }) {\n    return await this.executeWithRetry(async (apiKey) => {\n      logger.info(`Generating image for request ${requestId} using key ${apiKey.substring(0, 10)}...`);\n\n      let result;\n      if (this.useRelayApi) {\n        // ä¸­è½¬API (OpenAIæ ¼å¼)\n        result = await this.generateImageWithRelayApi(apiKey, prompt, refImages, options, requestId);\n      } else {\n        // ç›´è¿API (Geminiæ ¼å¼)\n        result = await this.generateImageWithDirectApi(apiKey, prompt, refImages, options, requestId);\n      }\n\n      // ç»Ÿä¸€è¿”å›æ ¼å¼ï¼Œç¡®ä¿ä¸å‰ç«¯æœŸæœ›ä¸€è‡´\n      return {\n        content: JSON.stringify({\n          images: result.images || []\n        }),\n        finishReason: result.finishReason || 'STOP',\n        safetyRatings: result.safetyRatings || [],\n        metadata: {\n          model: this.useRelayApi ? 'gemini-2.5-flash-image-preview' : 'gemini-2.5-flash-image-preview',\n          requestId,\n          timestamp: new Date().toISOString(),\n          apiType: this.useRelayApi ? 'relay' : 'direct'\n        }\n      };\n    }, 'Image Generation', requestId);\n  }\n\n  // ä¸­è½¬APIå›¾åƒç”Ÿæˆ\n  async generateImageWithRelayApi(apiKey, prompt, refImages, options, requestId) {\n    const messages = [\n      {\n        role: 'user',\n        content: [\n          {\n            type: 'text',\n            text: `Generate an image: ${prompt}`\n          }\n        ]\n      }\n    ];\n\n    // æ·»åŠ å‚è€ƒå›¾åƒï¼ˆä¸­è½¬APIæ”¯æŒbase64å›¾åƒï¼‰\n    if (refImages && refImages.length > 0) {\n      logger.info(`Adding ${refImages.length} reference images to relay API request`);\n      refImages.forEach(refImage => {\n        messages[0].content.push({\n          type: 'image_url',\n          image_url: {\n            url: `data:${refImage.mimeType || 'image/png'};base64,${refImage.data}`\n          }\n        });\n      });\n    }\n\n    const payload = {\n      model: 'gemini-2.5-flash-image-preview',\n      messages,\n      temperature: options.temperature || 0.7\n    };\n\n    logger.info(`Making request to Relay API for request ${requestId}:`, {\n      url: '/chat/completions',\n      model: payload.model\n    });\n\n    const response = await this.client.post('/chat/completions', payload, {\n      headers: {\n        'Authorization': `Bearer ${apiKey}`,\n        'Content-Type': 'application/json'\n      }\n    });\n\n    // ä»å“åº”ä¸­æå–å›¾ç‰‡URL\n    const content = response.data.choices[0].message.content || '';\n    const imageUrls = this.extractImageUrls(content);\n\n    logger.info(`Generated ${imageUrls.length} images via relay API for request ${requestId}`);\n    logger.info(`Response content preview: ${content.substring(0, 200)}...`);\n    logger.info(`Extracted image URLs: ${JSON.stringify(imageUrls)}`);\n\n    return {\n      images: imageUrls,\n      text: content\n    };\n  }\n\n  // ç›´è¿APIå›¾åƒç”Ÿæˆ\n  async generateImageWithDirectApi(apiKey, prompt, refImages, options, requestId) {\n    // åŸæœ‰çš„ç›´è¿APIé€»è¾‘\n    const imagePrompt = `Generate an image of: ${prompt}`;\n\n    const contents = [{\n      parts: [{ text: imagePrompt }]\n    }];\n\n    // æ·»åŠ å‚è€ƒå›¾åƒï¼ˆå¦‚æœæœ‰ï¼‰\n    if (refImages && refImages.length > 0) {\n      for (const refImage of refImages) {\n        contents[0].parts.push({\n          inlineData: {\n            mimeType: refImage.mimeType || 'image/png',\n            data: refImage.data\n          }\n        });\n      }\n    }\n\n    const payload = {\n      contents: contents,\n      generationConfig: {\n        temperature: options.temperature || 0.7,\n        topK: options.topK || 40,\n        topP: options.topP || 0.95,\n        maxOutputTokens: options.maxOutputTokens || 2048,\n      },\n      systemInstruction: {\n        parts: [{\n          text: \"You are an image generation AI. When given a prompt, generate an image that matches the description. Always output an image, not just text.\"\n        }]\n      },\n      safetySettings: [\n        {\n          category: \"HARM_CATEGORY_HARASSMENT\",\n          threshold: \"BLOCK_ONLY_HIGH\"\n        },\n        {\n          category: \"HARM_CATEGORY_HATE_SPEECH\",\n          threshold: \"BLOCK_ONLY_HIGH\"\n        },\n        {\n          category: \"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n          threshold: \"BLOCK_ONLY_HIGH\"\n        },\n        {\n          category: \"HARM_CATEGORY_DANGEROUS_CONTENT\",\n          threshold: \"BLOCK_ONLY_HIGH\"\n        }\n      ]\n    };\n\n    logger.info(`Making request to Direct Gemini API for request ${requestId}:`, {\n      url: `/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey.substring(0, 10)}...`\n    });\n\n    const response = await this.client.post(\n      `/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`,\n      payload\n    );\n\n    // Log the response for debugging\n    logger.info(`Gemini API response for request ${requestId}:`, {\n      status: response.status,\n      candidatesCount: response.data?.candidates?.length || 0,\n      firstCandidatePartsCount: response.data?.candidates?.[0]?.content?.parts?.length || 0\n    });\n\n    if (!response.data || !response.data.candidates) {\n      throw new Error('Invalid response from Gemini API');\n    }\n\n    const candidate = response.data.candidates[0];\n    if (!candidate || !candidate.content) {\n      throw new Error('No content generated');\n    }\n\n    // Extract generated images from the response\n    const images = [];\n    let textContent = '';\n\n    for (const part of candidate.content.parts) {\n      if (part.inlineData && part.inlineData.data) {\n        images.push(part.inlineData.data);\n      } else if (part.text) {\n        textContent += part.text;\n      }\n    }\n\n    logger.info(`Image generation completed for request ${requestId}, generated ${images.length} images`);\n\n    if (images.length === 0) {\n      logger.warn(`No images generated for request ${requestId}. Response parts:`,\n        candidate.content.parts.map(p => ({\n          hasText: !!p.text,\n          hasInlineData: !!p.inlineData,\n          textContent: p.text ? p.text.substring(0, 100) + '...' : null\n        })));\n      logger.warn(`Full response for debugging:`, JSON.stringify(response.data, null, 2));\n    }\n\n    return {\n      images,\n      text: textContent,\n      finishReason: candidate.finishReason,\n      safetyRatings: candidate.safetyRatings\n    };\n  }\n\n  // ä»å“åº”å†…å®¹ä¸­æå–å›¾ç‰‡URL (ç”¨äºä¸­è½¬API)\n  extractImageUrls(content) {\n    const imageUrls = [];\n\n    // åŒ¹é…å›¾ç‰‡URLçš„æ­£åˆ™è¡¨è¾¾å¼\n    const urlRegex = /https?:\\/\\/[^\\s\\)]+\\.(?:png|jpg|jpeg|gif|webp)/gi;\n    const matches = content.match(urlRegex);\n\n    if (matches) {\n      imageUrls.push(...matches);\n    }\n\n    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°URLï¼Œå¯èƒ½å›¾ç‰‡æ˜¯ä»¥base64å½¢å¼è¿”å›çš„\n    const base64Regex = /data:image\\/[^;]+;base64,([A-Za-z0-9+\\/=]+)/gi;\n    const base64Matches = content.match(base64Regex);\n\n    if (base64Matches) {\n      imageUrls.push(...base64Matches);\n    }\n\n    return imageUrls;\n  }\n\n  buildEditPrompt({ instruction, mask }) {\n    const maskInstruction = mask\n      ? \"\\n\\nCRITICAL MASK INSTRUCTIONS:\\n- Apply changes ONLY within the white areas (value 255) of the mask image\\n- REPLACE the existing content in the masked areas with the requested changes\\n- Do NOT add new elements outside the mask\\n- Do NOT keep the original elements in the masked areas\\n- Leave all areas outside the mask (black areas) completely unchanged\\n- Ensure seamless blending at the mask boundaries\"\n      : \"\";\n\n    return `EDIT TASK: ${instruction}\n\nREQUIREMENTS:\n- This is an EDITING task, not a generation task\n- REPLACE the specified elements, do not add to them\n- Maintain the original image's lighting, perspective, and overall composition\n- Make changes look natural and seamlessly integrated\n- Preserve image quality and ensure professional results${maskInstruction}\n\nIMPORTANT: If a mask is provided, you must ONLY modify the white areas of the mask and REPLACE what's there, not add to it.`;\n  }\n\n  async editImage({ imageId, mask, instruction, refImages = [], requestId }) {\n    return await this.executeWithRetry(async (apiKey) => {\n      logger.info(`Editing image for request ${requestId} using key ${apiKey.substring(0, 10)}...`);\n\n      // æ ¹æ®é…ç½®é€‰æ‹©API\n      if (this.useRelayApi) {\n        return await this.editImageWithRelayApi(apiKey, imageId, mask, instruction, refImages, requestId);\n      } else {\n        return await this.editImageWithDirectApi(apiKey, imageId, mask, instruction, refImages, requestId);\n      }\n    }, requestId, 'editImage');\n  }\n\n  // ä¸­è½¬APIå›¾åƒç¼–è¾‘\n  async editImageWithRelayApi(apiKey, imageId, mask, instruction, refImages, requestId) {\n    logger.info(`Using Relay API for image editing request ${requestId}`);\n\n    // æ„å»ºç¼–è¾‘æç¤ºè¯ï¼ŒåŒ…å«é®ç½©ä¿¡æ¯\n    let editPrompt = this.buildEditPrompt({ instruction, mask });\n\n    // å¦‚æœæœ‰é®ç½©ï¼Œæ·»åŠ ç‰¹æ®Šçš„é®ç½©å¤„ç†è¯´æ˜\n    if (mask) {\n      editPrompt += `\n\nMASK EDITING INSTRUCTIONS:\n- The user has painted specific areas on the image that need to be edited\n- Focus your changes ONLY on the painted/selected regions\n- The painted areas are shown with purple/violet overlay in the reference image\n- Keep all other areas of the image completely unchanged\n- Make the edits blend naturally with the surrounding areas\n- Do not modify areas that are not painted/selected`;\n    }\n\n    const messages = [\n      {\n        role: 'user',\n        content: [\n          {\n            type: 'text',\n            text: editPrompt\n          }\n        ]\n      }\n    ];\n\n    // æ·»åŠ åŸå§‹å›¾åƒï¼ˆç¬¬ä¸€ä¸ªå‚è€ƒå›¾åƒé€šå¸¸æ˜¯åŸå§‹å›¾åƒï¼‰\n    if (refImages && refImages.length > 0) {\n      let imageData = refImages[0].data;\n\n      // å¦‚æœimageIdæ˜¯URLï¼Œæˆ‘ä»¬éœ€è¦ä¸‹è½½å¹¶è½¬æ¢ä¸ºbase64\n      if (typeof imageId === 'string' && imageId.startsWith('http')) {\n        logger.info(`Image ID is URL, but using refImage data for relay API: ${imageId.substring(0, 50)}...`);\n        // ä½¿ç”¨ç¬¬ä¸€ä¸ªrefImageçš„æ•°æ®ï¼Œè¿™åº”è¯¥æ˜¯åŸå§‹å›¾åƒçš„base64æ•°æ®\n        imageData = refImages[0].data;\n      } else if (typeof imageId === 'string' && !imageId.startsWith('data:') && !imageId.startsWith('http')) {\n        // å¦‚æœimageIdæœ¬èº«å°±æ˜¯base64æ•°æ®\n        imageData = imageId;\n      }\n\n      messages[0].content.push({\n        type: 'image_url',\n        image_url: {\n          url: `data:${refImages[0].mimeType || 'image/png'};base64,${imageData}`\n        }\n      });\n\n      logger.info(`Added original image to relay API request, data length: ${imageData.length}`);\n    } else {\n      logger.warn(`No reference images provided for editing request ${requestId}`);\n    }\n\n    // å¤„ç†é®ç½©ä¿¡æ¯ï¼šå¦‚æœæœ‰é®ç½©ï¼Œæˆ‘ä»¬ä½¿ç”¨å¸¦é®ç½©è¦†ç›–çš„å‚è€ƒå›¾åƒ\n    if (mask && refImages && refImages.length > 1) {\n      logger.info(`Adding masked reference image to show selected areas for editing`);\n      // ç¬¬äºŒä¸ªrefImageåº”è¯¥æ˜¯å¸¦æœ‰é®ç½©è¦†ç›–çš„å›¾åƒ\n      messages[0].content.push({\n        type: 'image_url',\n        image_url: {\n          url: `data:image/png;base64,${refImages[1].data}`\n        }\n      });\n\n      // æ·»åŠ è¯´æ˜æ–‡æœ¬\n      messages[0].content.push({\n        type: 'text',\n        text: 'The second image shows the areas selected for editing (highlighted in purple). Please edit ONLY these highlighted areas.'\n      });\n    } else if (mask) {\n      logger.info(`Mask provided but no masked reference image available`);\n    }\n\n    const payload = {\n      model: 'gemini-2.5-flash-image-preview',\n      messages,\n      temperature: 0.7\n    };\n\n    logger.info(`Making request to Relay API for image editing ${requestId}:`, {\n      url: '/chat/completions',\n      model: payload.model,\n      hasOriginalImage: refImages && refImages.length > 0,\n      hasMask: !!mask,\n      instruction: instruction.substring(0, 100) + '...'\n    });\n\n    const response = await this.client.post('/chat/completions', payload, {\n      headers: {\n        'Authorization': `Bearer ${apiKey}`,\n        'Content-Type': 'application/json'\n      }\n    });\n\n    logger.info('Relay API response for editing:', {\n      status: response.status,\n      contentPreview: response.data.choices[0].message.content.substring(0, 200) + '...'\n    });\n\n    // ä»å“åº”ä¸­æå–å›¾ç‰‡URL\n    const content = response.data.choices[0].message.content || '';\n    const imageUrls = this.extractImageUrls(content);\n\n    logger.info(`Generated ${imageUrls.length} images via relay API for editing request ${requestId}`);\n    logger.info(`Extracted image URLs: ${JSON.stringify(imageUrls)}`);\n\n    return {\n      images: imageUrls,\n      text: content,\n      finishReason: 'STOP',\n      safetyRatings: [],\n      metadata: {\n        model: 'gemini-2.5-flash-image-preview',\n        requestId,\n        originalImageId: imageId,\n        timestamp: new Date().toISOString(),\n        apiType: 'relay'\n      }\n    };\n  }\n\n  // ç›´è¿APIå›¾åƒç¼–è¾‘\n  async editImageWithDirectApi(apiKey, imageId, mask, instruction, refImages, requestId) {\n    logger.info(`Using Direct Gemini API for image editing request ${requestId}`);\n\n    // Build the proper edit prompt\n    const editPrompt = this.buildEditPrompt({ instruction, mask });\n\n    // Structure contents in the correct order: text -> original -> references -> mask\n    const contents = [{\n      parts: [{ text: editPrompt }]\n    }];\n\n    // Add the original image (first reference image is the original)\n    if (refImages && refImages.length > 0) {\n      contents[0].parts.push({\n        inlineData: {\n          mimeType: refImages[0].mimeType || 'image/png',\n          data: refImages[0].data\n        }\n      });\n\n      // Add additional reference images if any\n      for (let i = 1; i < refImages.length; i++) {\n        contents[0].parts.push({\n          inlineData: {\n            mimeType: refImages[i].mimeType || 'image/png',\n            data: refImages[i].data\n          }\n        });\n      }\n    }\n\n    // Add mask as the last element if provided\n    if (mask) {\n      contents[0].parts.push({\n        inlineData: {\n          mimeType: 'image/png',\n          data: mask\n        }\n      });\n\n      logger.info('Added mask to request:', {\n        maskSize: mask.length,\n        maskPreview: mask.substring(0, 50) + '...'\n      });\n    }\n\n    const payload = {\n      contents,\n      generationConfig: {\n        temperature: 0.7,\n        topK: 40,\n        topP: 0.95,\n        maxOutputTokens: 2048,\n      },\n      // Relaxed safety settings for creative content\n      safetySettings: [\n        {\n          category: \"HARM_CATEGORY_HARASSMENT\",\n          threshold: \"BLOCK_ONLY_HIGH\"\n        },\n        {\n          category: \"HARM_CATEGORY_HATE_SPEECH\",\n          threshold: \"BLOCK_ONLY_HIGH\"\n        },\n        {\n          category: \"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n          threshold: \"BLOCK_ONLY_HIGH\"\n        },\n        {\n          category: \"HARM_CATEGORY_DANGEROUS_CONTENT\",\n          threshold: \"BLOCK_ONLY_HIGH\"\n        }\n      ]\n    };\n\n    logger.info('Making request to Gemini API for image editing:', {\n      url: `/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey.substring(0, 10)}...`,\n      prompt: editPrompt,\n      hasOriginalImage: refImages.length > 0,\n      hasReferenceImages: refImages.length > 1,\n      hasMask: !!mask,\n      partsCount: contents[0].parts.length\n    });\n\n    const response = await this.client.post(\n      `/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`,\n      payload\n    );\n\n    logger.info('Gemini API response for editing:', {\n      status: response.status,\n      data: JSON.stringify(response.data, null, 2).substring(0, 500) + '...'\n    });\n\n    if (!response.data || !response.data.candidates) {\n      // Check for content blocking\n      if (response.data && response.data.promptFeedback && response.data.promptFeedback.blockReason) {\n        const blockReason = response.data.promptFeedback.blockReason;\n        logger.error('Content blocked by Gemini API:', { blockReason });\n        throw new Error(`Content blocked: ${blockReason}. Please try a different prompt that doesn't contain potentially sensitive content.`);\n      }\n      throw new Error('Invalid response from Gemini API');\n    }\n\n    const candidate = response.data.candidates[0];\n    if (!candidate || !candidate.content) {\n      throw new Error('No content generated');\n    }\n\n    // Extract images from the response\n    const images = [];\n    for (const part of candidate.content.parts) {\n      if (part.inlineData && part.inlineData.mimeType && part.inlineData.mimeType.startsWith('image/')) {\n        images.push(part.inlineData.data);\n      }\n    }\n\n    logger.info(`Image editing completed for request ${requestId}, generated ${images.length} images`);\n\n    if (images.length === 0) {\n      logger.warn(`No images generated for request ${requestId}. Response parts:`,\n        candidate.content.parts.map(part => ({\n          hasText: !!part.text,\n          hasInlineData: !!part.inlineData\n        }))\n      );\n\n      // Generate a mock edited image for now\n      const mockImage = this.generateMockImage(instruction);\n      images.push(mockImage);\n    }\n\n    return {\n      images,\n      finishReason: candidate.finishReason,\n      safetyRatings: candidate.safetyRatings,\n      metadata: {\n        model: 'gemini-2.5-flash-image-preview',\n        requestId,\n        originalImageId: imageId,\n        timestamp: new Date().toISOString()\n      }\n    };\n  }\n\n  // å¸¦é‡è¯•æœºåˆ¶çš„æ‰§è¡Œæ–¹æ³•\n  async executeWithRetry(operation, requestId, operationType, maxRetries = 3) {\n    let lastError;\n    let attemptCount = 0;\n\n    while (attemptCount < maxRetries) {\n      attemptCount++;\n\n      try {\n        // æ£€æŸ¥æ˜¯å¦æœ‰å¯ç”¨çš„APIå¯†é’¥\n        if (!this.apiKeyManager.hasAvailableKeys()) {\n          throw new Error('æ‰€æœ‰APIå¯†é’¥éƒ½å·²è¾¾åˆ°é™åˆ¶æˆ–è¢«ç¦ç”¨ï¼Œè¯·ç¨åå†è¯•');\n        }\n\n        // è·å–ä¸‹ä¸€ä¸ªå¯ç”¨çš„APIå¯†é’¥\n        const apiKey = this.apiKeyManager.getNextApiKey();\n\n        logger.info(`ğŸ”„ Attempt ${attemptCount}/${maxRetries} for ${operationType} (${requestId}) using key ${apiKey.substring(0, 10)}...`);\n\n        // æ‰§è¡Œæ“ä½œ\n        const result = await operation(apiKey);\n\n        logger.info(`âœ… ${operationType} succeeded on attempt ${attemptCount} for request ${requestId}`);\n        return result;\n\n      } catch (error) {\n        lastError = error;\n\n        // è·å–å½“å‰ä½¿ç”¨çš„APIå¯†é’¥ï¼ˆä»é”™è¯¯ä¸­æ¨æ–­æˆ–ä½¿ç”¨æœ€åä¸€ä¸ªï¼‰\n        const currentApiKey = this.apiKeyManager.getNextApiKey();\n\n        // è®°å½•APIå¯†é’¥é”™è¯¯\n        this.apiKeyManager.recordKeyError(currentApiKey, error);\n\n        const isRetryableError = this.isRetryableError(error);\n\n        logger.warn(`âŒ Attempt ${attemptCount}/${maxRetries} failed for ${operationType} (${requestId}):`, {\n          error: error.message,\n          isRetryable: isRetryableError,\n          willRetry: attemptCount < maxRetries && isRetryableError\n        });\n\n        // å¦‚æœä¸æ˜¯å¯é‡è¯•çš„é”™è¯¯ï¼Œæˆ–è€…å·²ç»è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œç›´æ¥æŠ›å‡ºé”™è¯¯\n        if (!isRetryableError || attemptCount >= maxRetries) {\n          break;\n        }\n\n        // ç­‰å¾…ä¸€æ®µæ—¶é—´åé‡è¯•ï¼ˆæŒ‡æ•°é€€é¿ï¼‰\n        const delay = Math.min(1000 * Math.pow(2, attemptCount - 1), 5000);\n        logger.info(`â³ Waiting ${delay}ms before retry...`);\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n\n    // æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥äº†ï¼ŒæŠ›å‡ºæœ€åä¸€ä¸ªé”™è¯¯\n    const friendlyMessage = this.getFriendlyErrorMessage(lastError);\n    logger.error(`ğŸ’¥ All ${maxRetries} attempts failed for ${operationType} (${requestId}): ${friendlyMessage}`);\n    throw new Error(friendlyMessage);\n  }\n\n  // åˆ¤æ–­é”™è¯¯æ˜¯å¦å¯é‡è¯•\n  isRetryableError(error) {\n    const message = error.message || error.toString();\n    const statusCode = error.response?.status;\n\n    // ä¸å¯é‡è¯•çš„é”™è¯¯\n    if (statusCode === 400) return false; // è¯·æ±‚æ ¼å¼é”™è¯¯\n    if (statusCode === 401) return false; // è®¤è¯é”™è¯¯\n    if (statusCode === 403) return false; // æƒé™é”™è¯¯\n    if (message.includes('Invalid request')) return false;\n    if (message.includes('Content blocked')) return false;\n\n    // å¯é‡è¯•çš„é”™è¯¯\n    if (statusCode === 429) return true; // é€Ÿç‡é™åˆ¶\n    if (statusCode >= 500) return true; // æœåŠ¡å™¨é”™è¯¯\n    if (message.includes('timeout')) return true;\n    if (message.includes('network')) return true;\n    if (message.includes('Rate limit')) return true;\n\n    // é»˜è®¤å¯é‡è¯•\n    return true;\n  }\n\n  // è·å–ç”¨æˆ·å‹å¥½çš„é”™è¯¯æ¶ˆæ¯\n  getFriendlyErrorMessage(error) {\n    const message = error.message || error.toString();\n    const statusCode = error.response?.status;\n\n    if (message.includes('æ‰€æœ‰APIå¯†é’¥éƒ½å·²è¾¾åˆ°é™åˆ¶')) {\n      return 'æ‰€æœ‰APIå¯†é’¥éƒ½å·²è¾¾åˆ°ä½¿ç”¨é™åˆ¶ï¼Œè¯·ç¨åå†è¯•';\n    }\n\n    if (statusCode === 429 || message.includes('Rate limit')) {\n      return 'è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•';\n    }\n\n    if (statusCode === 403 || message.includes('invalid') || message.includes('permissions')) {\n      return 'APIå¯†é’¥æ— æ•ˆæˆ–æƒé™ä¸è¶³ï¼Œè¯·æ£€æŸ¥é…ç½®';\n    }\n\n    if (message.includes('Content blocked')) {\n      return 'å†…å®¹è¢«å®‰å…¨è¿‡æ»¤å™¨é˜»æ­¢ï¼Œè¯·å°è¯•ä¿®æ”¹æ‚¨çš„æè¿°';\n    }\n\n    if (statusCode >= 500) {\n      return 'æœåŠ¡æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·ç¨åå†è¯•';\n    }\n\n    if (message.includes('timeout')) {\n      return 'è¯·æ±‚è¶…æ—¶ï¼Œè¯·ç¨åå†è¯•';\n    }\n\n    // é»˜è®¤é”™è¯¯æ¶ˆæ¯\n    return 'å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œè¯·ç¨åå†è¯•';\n  }\n\n  // Generate a mock image for demonstration purposes\n  // In a real implementation, you would integrate with an actual image generation service\n  generateMockImage(prompt) {\n    // Create a simple colored rectangle as a placeholder\n    // This is a 1x1 pixel red PNG in base64\n    const mockImageBase64 = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==';\n\n    logger.info(`Generated mock image for prompt: ${prompt.substring(0, 50)}`);\n    return mockImageBase64;\n  }\n\n  // è·å–APIå¯†é’¥ç»Ÿè®¡ä¿¡æ¯\n  getApiKeyStats() {\n    return this.apiKeyManager.getKeyStats();\n  }\n}\n\nmodule.exports = new GeminiService();\n"