const axios = require('axios');\nconst logger = require('../utils/logger');\nconst ApiKeyManager = require('./apiKeyManager');\n\nclass GeminiService {\n  constructor() {\n    this.apiKeyManager = new ApiKeyManager();\n    this.useRelayApi = process.env.USE_RELAY_API === 'true';\n\n    if (this.useRelayApi) {\n      // 中转API配置\n      this.baseUrl = process.env.RELAY_API_URL || 'https://hiapi.online/v1';\n      this.isOpenAICompatible = true;\n      logger.info('🔄 Initialized with Relay API (OpenAI-compatible)');\n    } else {\n      // 传统直连API配置\n      this.baseUrl = process.env.GEMINI_API_URL || 'https://generativelanguage.googleapis.com/v1beta';\n      this.isOpenAICompatible = false;\n      logger.info('🔗 Initialized with Direct Gemini API');\n    }\n\n    this.client = axios.create({\n      baseURL: this.baseUrl,\n      timeout: 60000, // 60 seconds timeout\n      headers: {\n        'Content-Type': 'application/json',\n      }\n    });\n  }\n\n  async generateImage({ prompt, refImages = [], options = {}, requestId }) {\n    return await this.executeWithRetry(async (apiKey) => {\n      logger.info(`Generating image for request ${requestId} using key ${apiKey.substring(0, 10)}...`);\n\n      let result;\n      if (this.useRelayApi) {\n        // 中转API (OpenAI格式)\n        result = await this.generateImageWithRelayApi(apiKey, prompt, refImages, options, requestId);\n      } else {\n        // 直连API (Gemini格式)\n        result = await this.generateImageWithDirectApi(apiKey, prompt, refImages, options, requestId);\n      }\n\n      // 统一返回格式，确保与前端期望一致\n      return {\n        content: JSON.stringify({\n          images: result.images || []\n        }),\n        finishReason: result.finishReason || 'STOP',\n        safetyRatings: result.safetyRatings || [],\n        metadata: {\n          model: this.useRelayApi ? 'gemini-2.5-flash-image-preview' : 'gemini-2.5-flash-image-preview',\n          requestId,\n          timestamp: new Date().toISOString(),\n          apiType: this.useRelayApi ? 'relay' : 'direct'\n        }\n      };\n    }, 'Image Generation', requestId);\n  }\n\n  // 中转API图像生成\n  async generateImageWithRelayApi(apiKey, prompt, refImages, options, requestId) {\n    const messages = [\n      {\n        role: 'user',\n        content: [\n          {\n            type: 'text',\n            text: `Generate an image: ${prompt}`\n          }\n        ]\n      }\n    ];\n\n    // 添加参考图像（中转API支持base64图像）\n    if (refImages && refImages.length > 0) {\n      logger.info(`Adding ${refImages.length} reference images to relay API request`);\n      refImages.forEach(refImage => {\n        messages[0].content.push({\n          type: 'image_url',\n          image_url: {\n            url: `data:${refImage.mimeType || 'image/png'};base64,${refImage.data}`\n          }\n        });\n      });\n    }\n\n    const payload = {\n      model: 'gemini-2.5-flash-image-preview',\n      messages,\n      temperature: options.temperature || 0.7\n    };\n\n    logger.info(`Making request to Relay API for request ${requestId}:`, {\n      url: '/chat/completions',\n      model: payload.model\n    });\n\n    const response = await this.client.post('/chat/completions', payload, {\n      headers: {\n        'Authorization': `Bearer ${apiKey}`,\n        'Content-Type': 'application/json'\n      }\n    });\n\n    // 从响应中提取图片URL\n    const content = response.data.choices[0].message.content || '';\n    const imageUrls = this.extractImageUrls(content);\n\n    logger.info(`Generated ${imageUrls.length} images via relay API for request ${requestId}`);\n    logger.info(`Response content preview: ${content.substring(0, 200)}...`);\n    logger.info(`Extracted image URLs: ${JSON.stringify(imageUrls)}`);\n\n    return {\n      images: imageUrls,\n      text: content\n    };\n  }\n\n  // 直连API图像生成\n  async generateImageWithDirectApi(apiKey, prompt, refImages, options, requestId) {\n    // 原有的直连API逻辑\n    const imagePrompt = `Generate an image of: ${prompt}`;\n\n    const contents = [{\n      parts: [{ text: imagePrompt }]\n    }];\n\n    // 添加参考图像（如果有）\n    if (refImages && refImages.length > 0) {\n      for (const refImage of refImages) {\n        contents[0].parts.push({\n          inlineData: {\n            mimeType: refImage.mimeType || 'image/png',\n            data: refImage.data\n          }\n        });\n      }\n    }\n\n    const payload = {\n      contents: contents,\n      generationConfig: {\n        temperature: options.temperature || 0.7,\n        topK: options.topK || 40,\n        topP: options.topP || 0.95,\n        maxOutputTokens: options.maxOutputTokens || 2048,\n      },\n      systemInstruction: {\n        parts: [{\n          text: \"You are an image generation AI. When given a prompt, generate an image that matches the description. Always output an image, not just text.\"\n        }]\n      },\n      safetySettings: [\n        {\n          category: \"HARM_CATEGORY_HARASSMENT\",\n          threshold: \"BLOCK_ONLY_HIGH\"\n        },\n        {\n          category: \"HARM_CATEGORY_HATE_SPEECH\",\n          threshold: \"BLOCK_ONLY_HIGH\"\n        },\n        {\n          category: \"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n          threshold: \"BLOCK_ONLY_HIGH\"\n        },\n        {\n          category: \"HARM_CATEGORY_DANGEROUS_CONTENT\",\n          threshold: \"BLOCK_ONLY_HIGH\"\n        }\n      ]\n    };\n\n    logger.info(`Making request to Direct Gemini API for request ${requestId}:`, {\n      url: `/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey.substring(0, 10)}...`\n    });\n\n    const response = await this.client.post(\n      `/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`,\n      payload\n    );\n\n    // Log the response for debugging\n    logger.info(`Gemini API response for request ${requestId}:`, {\n      status: response.status,\n      candidatesCount: response.data?.candidates?.length || 0,\n      firstCandidatePartsCount: response.data?.candidates?.[0]?.content?.parts?.length || 0\n    });\n\n    if (!response.data || !response.data.candidates) {\n      throw new Error('Invalid response from Gemini API');\n    }\n\n    const candidate = response.data.candidates[0];\n    if (!candidate || !candidate.content) {\n      throw new Error('No content generated');\n    }\n\n    // Extract generated images from the response\n    const images = [];\n    let textContent = '';\n\n    for (const part of candidate.content.parts) {\n      if (part.inlineData && part.inlineData.data) {\n        images.push(part.inlineData.data);\n      } else if (part.text) {\n        textContent += part.text;\n      }\n    }\n\n    logger.info(`Image generation completed for request ${requestId}, generated ${images.length} images`);\n\n    if (images.length === 0) {\n      logger.warn(`No images generated for request ${requestId}. Response parts:`,\n        candidate.content.parts.map(p => ({\n          hasText: !!p.text,\n          hasInlineData: !!p.inlineData,\n          textContent: p.text ? p.text.substring(0, 100) + '...' : null\n        })));\n      logger.warn(`Full response for debugging:`, JSON.stringify(response.data, null, 2));\n    }\n\n    return {\n      images,\n      text: textContent,\n      finishReason: candidate.finishReason,\n      safetyRatings: candidate.safetyRatings\n    };\n  }\n\n  // 从响应内容中提取图片URL (用于中转API)\n  extractImageUrls(content) {\n    const imageUrls = [];\n\n    // 匹配图片URL的正则表达式\n    const urlRegex = /https?:\\/\\/[^\\s\\)]+\\.(?:png|jpg|jpeg|gif|webp)/gi;\n    const matches = content.match(urlRegex);\n\n    if (matches) {\n      imageUrls.push(...matches);\n    }\n\n    // 如果没有找到URL，可能图片是以base64形式返回的\n    const base64Regex = /data:image\\/[^;]+;base64,([A-Za-z0-9+\\/=]+)/gi;\n    const base64Matches = content.match(base64Regex);\n\n    if (base64Matches) {\n      imageUrls.push(...base64Matches);\n    }\n\n    return imageUrls;\n  }\n\n  buildEditPrompt({ instruction, mask }) {\n    const maskInstruction = mask\n      ? \"\\n\\nCRITICAL MASK INSTRUCTIONS:\\n- Apply changes ONLY within the white areas (value 255) of the mask image\\n- REPLACE the existing content in the masked areas with the requested changes\\n- Do NOT add new elements outside the mask\\n- Do NOT keep the original elements in the masked areas\\n- Leave all areas outside the mask (black areas) completely unchanged\\n- Ensure seamless blending at the mask boundaries\"\n      : \"\";\n\n    return `EDIT TASK: ${instruction}\n\nREQUIREMENTS:\n- This is an EDITING task, not a generation task\n- REPLACE the specified elements, do not add to them\n- Maintain the original image's lighting, perspective, and overall composition\n- Make changes look natural and seamlessly integrated\n- Preserve image quality and ensure professional results${maskInstruction}\n\nIMPORTANT: If a mask is provided, you must ONLY modify the white areas of the mask and REPLACE what's there, not add to it.`;\n  }\n\n  async editImage({ imageId, mask, instruction, refImages = [], requestId }) {\n    return await this.executeWithRetry(async (apiKey) => {\n      logger.info(`Editing image for request ${requestId} using key ${apiKey.substring(0, 10)}...`);\n\n      // 根据配置选择API\n      if (this.useRelayApi) {\n        return await this.editImageWithRelayApi(apiKey, imageId, mask, instruction, refImages, requestId);\n      } else {\n        return await this.editImageWithDirectApi(apiKey, imageId, mask, instruction, refImages, requestId);\n      }\n    }, requestId, 'editImage');\n  }\n\n  // 中转API图像编辑\n  async editImageWithRelayApi(apiKey, imageId, mask, instruction, refImages, requestId) {\n    logger.info(`Using Relay API for image editing request ${requestId}`);\n\n    // 构建编辑提示词，包含遮罩信息\n    let editPrompt = this.buildEditPrompt({ instruction, mask });\n\n    // 如果有遮罩，添加特殊的遮罩处理说明\n    if (mask) {\n      editPrompt += `\n\nMASK EDITING INSTRUCTIONS:\n- The user has painted specific areas on the image that need to be edited\n- Focus your changes ONLY on the painted/selected regions\n- The painted areas are shown with purple/violet overlay in the reference image\n- Keep all other areas of the image completely unchanged\n- Make the edits blend naturally with the surrounding areas\n- Do not modify areas that are not painted/selected`;\n    }\n\n    const messages = [\n      {\n        role: 'user',\n        content: [\n          {\n            type: 'text',\n            text: editPrompt\n          }\n        ]\n      }\n    ];\n\n    // 添加原始图像（第一个参考图像通常是原始图像）\n    if (refImages && refImages.length > 0) {\n      let imageData = refImages[0].data;\n\n      // 如果imageId是URL，我们需要下载并转换为base64\n      if (typeof imageId === 'string' && imageId.startsWith('http')) {\n        logger.info(`Image ID is URL, but using refImage data for relay API: ${imageId.substring(0, 50)}...`);\n        // 使用第一个refImage的数据，这应该是原始图像的base64数据\n        imageData = refImages[0].data;\n      } else if (typeof imageId === 'string' && !imageId.startsWith('data:') && !imageId.startsWith('http')) {\n        // 如果imageId本身就是base64数据\n        imageData = imageId;\n      }\n\n      messages[0].content.push({\n        type: 'image_url',\n        image_url: {\n          url: `data:${refImages[0].mimeType || 'image/png'};base64,${imageData}`\n        }\n      });\n\n      logger.info(`Added original image to relay API request, data length: ${imageData.length}`);\n    } else {\n      logger.warn(`No reference images provided for editing request ${requestId}`);\n    }\n\n    // 处理遮罩信息：如果有遮罩，我们使用带遮罩覆盖的参考图像\n    if (mask && refImages && refImages.length > 1) {\n      logger.info(`Adding masked reference image to show selected areas for editing`);\n      // 第二个refImage应该是带有遮罩覆盖的图像\n      messages[0].content.push({\n        type: 'image_url',\n        image_url: {\n          url: `data:image/png;base64,${refImages[1].data}`\n        }\n      });\n\n      // 添加说明文本\n      messages[0].content.push({\n        type: 'text',\n        text: 'The second image shows the areas selected for editing (highlighted in purple). Please edit ONLY these highlighted areas.'\n      });\n    } else if (mask) {\n      logger.info(`Mask provided but no masked reference image available`);\n    }\n\n    const payload = {\n      model: 'gemini-2.5-flash-image-preview',\n      messages,\n      temperature: 0.7\n    };\n\n    logger.info(`Making request to Relay API for image editing ${requestId}:`, {\n      url: '/chat/completions',\n      model: payload.model,\n      hasOriginalImage: refImages && refImages.length > 0,\n      hasMask: !!mask,\n      instruction: instruction.substring(0, 100) + '...'\n    });\n\n    const response = await this.client.post('/chat/completions', payload, {\n      headers: {\n        'Authorization': `Bearer ${apiKey}`,\n        'Content-Type': 'application/json'\n      }\n    });\n\n    logger.info('Relay API response for editing:', {\n      status: response.status,\n      contentPreview: response.data.choices[0].message.content.substring(0, 200) + '...'\n    });\n\n    // 从响应中提取图片URL\n    const content = response.data.choices[0].message.content || '';\n    const imageUrls = this.extractImageUrls(content);\n\n    logger.info(`Generated ${imageUrls.length} images via relay API for editing request ${requestId}`);\n    logger.info(`Extracted image URLs: ${JSON.stringify(imageUrls)}`);\n\n    return {\n      images: imageUrls,\n      text: content,\n      finishReason: 'STOP',\n      safetyRatings: [],\n      metadata: {\n        model: 'gemini-2.5-flash-image-preview',\n        requestId,\n        originalImageId: imageId,\n        timestamp: new Date().toISOString(),\n        apiType: 'relay'\n      }\n    };\n  }\n\n  // 直连API图像编辑\n  async editImageWithDirectApi(apiKey, imageId, mask, instruction, refImages, requestId) {\n    logger.info(`Using Direct Gemini API for image editing request ${requestId}`);\n\n    // Build the proper edit prompt\n    const editPrompt = this.buildEditPrompt({ instruction, mask });\n\n    // Structure contents in the correct order: text -> original -> references -> mask\n    const contents = [{\n      parts: [{ text: editPrompt }]\n    }];\n\n    // Add the original image (first reference image is the original)\n    if (refImages && refImages.length > 0) {\n      contents[0].parts.push({\n        inlineData: {\n          mimeType: refImages[0].mimeType || 'image/png',\n          data: refImages[0].data\n        }\n      });\n\n      // Add additional reference images if any\n      for (let i = 1; i < refImages.length; i++) {\n        contents[0].parts.push({\n          inlineData: {\n            mimeType: refImages[i].mimeType || 'image/png',\n            data: refImages[i].data\n          }\n        });\n      }\n    }\n\n    // Add mask as the last element if provided\n    if (mask) {\n      contents[0].parts.push({\n        inlineData: {\n          mimeType: 'image/png',\n          data: mask\n        }\n      });\n\n      logger.info('Added mask to request:', {\n        maskSize: mask.length,\n        maskPreview: mask.substring(0, 50) + '...'\n      });\n    }\n\n    const payload = {\n      contents,\n      generationConfig: {\n        temperature: 0.7,\n        topK: 40,\n        topP: 0.95,\n        maxOutputTokens: 2048,\n      },\n      // Relaxed safety settings for creative content\n      safetySettings: [\n        {\n          category: \"HARM_CATEGORY_HARASSMENT\",\n          threshold: \"BLOCK_ONLY_HIGH\"\n        },\n        {\n          category: \"HARM_CATEGORY_HATE_SPEECH\",\n          threshold: \"BLOCK_ONLY_HIGH\"\n        },\n        {\n          category: \"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n          threshold: \"BLOCK_ONLY_HIGH\"\n        },\n        {\n          category: \"HARM_CATEGORY_DANGEROUS_CONTENT\",\n          threshold: \"BLOCK_ONLY_HIGH\"\n        }\n      ]\n    };\n\n    logger.info('Making request to Gemini API for image editing:', {\n      url: `/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey.substring(0, 10)}...`,\n      prompt: editPrompt,\n      hasOriginalImage: refImages.length > 0,\n      hasReferenceImages: refImages.length > 1,\n      hasMask: !!mask,\n      partsCount: contents[0].parts.length\n    });\n\n    const response = await this.client.post(\n      `/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`,\n      payload\n    );\n\n    logger.info('Gemini API response for editing:', {\n      status: response.status,\n      data: JSON.stringify(response.data, null, 2).substring(0, 500) + '...'\n    });\n\n    if (!response.data || !response.data.candidates) {\n      // Check for content blocking\n      if (response.data && response.data.promptFeedback && response.data.promptFeedback.blockReason) {\n        const blockReason = response.data.promptFeedback.blockReason;\n        logger.error('Content blocked by Gemini API:', { blockReason });\n        throw new Error(`Content blocked: ${blockReason}. Please try a different prompt that doesn't contain potentially sensitive content.`);\n      }\n      throw new Error('Invalid response from Gemini API');\n    }\n\n    const candidate = response.data.candidates[0];\n    if (!candidate || !candidate.content) {\n      throw new Error('No content generated');\n    }\n\n    // Extract images from the response\n    const images = [];\n    for (const part of candidate.content.parts) {\n      if (part.inlineData && part.inlineData.mimeType && part.inlineData.mimeType.startsWith('image/')) {\n        images.push(part.inlineData.data);\n      }\n    }\n\n    logger.info(`Image editing completed for request ${requestId}, generated ${images.length} images`);\n\n    if (images.length === 0) {\n      logger.warn(`No images generated for request ${requestId}. Response parts:`,\n        candidate.content.parts.map(part => ({\n          hasText: !!part.text,\n          hasInlineData: !!part.inlineData\n        }))\n      );\n\n      // Generate a mock edited image for now\n      const mockImage = this.generateMockImage(instruction);\n      images.push(mockImage);\n    }\n\n    return {\n      images,\n      finishReason: candidate.finishReason,\n      safetyRatings: candidate.safetyRatings,\n      metadata: {\n        model: 'gemini-2.5-flash-image-preview',\n        requestId,\n        originalImageId: imageId,\n        timestamp: new Date().toISOString()\n      }\n    };\n  }\n\n  // 带重试机制的执行方法\n  async executeWithRetry(operation, requestId, operationType, maxRetries = 3) {\n    let lastError;\n    let attemptCount = 0;\n\n    while (attemptCount < maxRetries) {\n      attemptCount++;\n\n      try {\n        // 检查是否有可用的API密钥\n        if (!this.apiKeyManager.hasAvailableKeys()) {\n          throw new Error('所有API密钥都已达到限制或被禁用，请稍后再试');\n        }\n\n        // 获取下一个可用的API密钥\n        const apiKey = this.apiKeyManager.getNextApiKey();\n\n        logger.info(`🔄 Attempt ${attemptCount}/${maxRetries} for ${operationType} (${requestId}) using key ${apiKey.substring(0, 10)}...`);\n\n        // 执行操作\n        const result = await operation(apiKey);\n\n        logger.info(`✅ ${operationType} succeeded on attempt ${attemptCount} for request ${requestId}`);\n        return result;\n\n      } catch (error) {\n        lastError = error;\n\n        // 获取当前使用的API密钥（从错误中推断或使用最后一个）\n        const currentApiKey = this.apiKeyManager.getNextApiKey();\n\n        // 记录API密钥错误\n        this.apiKeyManager.recordKeyError(currentApiKey, error);\n\n        const isRetryableError = this.isRetryableError(error);\n\n        logger.warn(`❌ Attempt ${attemptCount}/${maxRetries} failed for ${operationType} (${requestId}):`, {\n          error: error.message,\n          isRetryable: isRetryableError,\n          willRetry: attemptCount < maxRetries && isRetryableError\n        });\n\n        // 如果不是可重试的错误，或者已经达到最大重试次数，直接抛出错误\n        if (!isRetryableError || attemptCount >= maxRetries) {\n          break;\n        }\n\n        // 等待一段时间后重试（指数退避）\n        const delay = Math.min(1000 * Math.pow(2, attemptCount - 1), 5000);\n        logger.info(`⏳ Waiting ${delay}ms before retry...`);\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n\n    // 所有重试都失败了，抛出最后一个错误\n    const friendlyMessage = this.getFriendlyErrorMessage(lastError);\n    logger.error(`💥 All ${maxRetries} attempts failed for ${operationType} (${requestId}): ${friendlyMessage}`);\n    throw new Error(friendlyMessage);\n  }\n\n  // 判断错误是否可重试\n  isRetryableError(error) {\n    const message = error.message || error.toString();\n    const statusCode = error.response?.status;\n\n    // 不可重试的错误\n    if (statusCode === 400) return false; // 请求格式错误\n    if (statusCode === 401) return false; // 认证错误\n    if (statusCode === 403) return false; // 权限错误\n    if (message.includes('Invalid request')) return false;\n    if (message.includes('Content blocked')) return false;\n\n    // 可重试的错误\n    if (statusCode === 429) return true; // 速率限制\n    if (statusCode >= 500) return true; // 服务器错误\n    if (message.includes('timeout')) return true;\n    if (message.includes('network')) return true;\n    if (message.includes('Rate limit')) return true;\n\n    // 默认可重试\n    return true;\n  }\n\n  // 获取用户友好的错误消息\n  getFriendlyErrorMessage(error) {\n    const message = error.message || error.toString();\n    const statusCode = error.response?.status;\n\n    if (message.includes('所有API密钥都已达到限制')) {\n      return '所有API密钥都已达到使用限制，请稍后再试';\n    }\n\n    if (statusCode === 429 || message.includes('Rate limit')) {\n      return '请求过于频繁，请稍后再试';\n    }\n\n    if (statusCode === 403 || message.includes('invalid') || message.includes('permissions')) {\n      return 'API密钥无效或权限不足，请检查配置';\n    }\n\n    if (message.includes('Content blocked')) {\n      return '内容被安全过滤器阻止，请尝试修改您的描述';\n    }\n\n    if (statusCode >= 500) {\n      return '服务暂时不可用，请稍后再试';\n    }\n\n    if (message.includes('timeout')) {\n      return '请求超时，请稍后再试';\n    }\n\n    // 默认错误消息\n    return '图片处理失败，请稍后再试';\n  }\n\n  // Generate a mock image for demonstration purposes\n  // In a real implementation, you would integrate with an actual image generation service\n  generateMockImage(prompt) {\n    // Create a simple colored rectangle as a placeholder\n    // This is a 1x1 pixel red PNG in base64\n    const mockImageBase64 = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==';\n\n    logger.info(`Generated mock image for prompt: ${prompt.substring(0, 50)}`);\n    return mockImageBase64;\n  }\n\n  // 获取API密钥统计信息\n  getApiKeyStats() {\n    return this.apiKeyManager.getKeyStats();\n  }\n}\n\nmodule.exports = new GeminiService();\n"