const sqlite3 = require('sqlite3').verbose();\nconst path = require('path');\nconst fs = require('fs');\nconst logger = require('../utils/logger');\n\nclass DatabaseService {\n  constructor() {\n    this.db = null;\n    this.dbPath = process.env.DATABASE_PATH || './data/proxy.db';\n  }\n\n  init() {\n    try {\n      // Ensure data directory exists\n      const dataDir = path.dirname(this.dbPath);\n      if (!fs.existsSync(dataDir)) {\n        fs.mkdirSync(dataDir, { recursive: true });\n      }\n\n      // Initialize SQLite database\n      this.db = new sqlite3.Database(this.dbPath, (err) => {\n        if (err) {\n          logger.error('Error opening database:', err);\n          throw err;\n        }\n        logger.info(`Database connected: ${this.dbPath}`);\n      });\n\n      // Create tables\n      this.createTables();\n    } catch (error) {\n      logger.error('Database initialization failed:', error);\n      throw error;\n    }\n  }\n\n  createTables() {\n    const tables = [\n      // Users table (mirrors Casdoor users)\n      `CREATE TABLE IF NOT EXISTS users (\n        id TEXT PRIMARY KEY,\n        casdoor_user_id TEXT UNIQUE NOT NULL,\n        email TEXT,\n        nickname TEXT,\n        status TEXT DEFAULT 'active',\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n      )`,\n\n      // Plan catalog table (create first as it's referenced by others)\n      `CREATE TABLE IF NOT EXISTS plan_catalog (\n        plan_code TEXT PRIMARY KEY,\n        name TEXT NOT NULL,\n        monthly_credits INTEGER DEFAULT 0,\n        features TEXT, -- JSON string\n        concurrency_limit INTEGER DEFAULT 1,\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n      )`,\n\n      // Subscriptions table (mirrors Casdoor subscriptions)\n      `CREATE TABLE IF NOT EXISTS subscriptions (\n        id TEXT PRIMARY KEY,\n        user_id TEXT NOT NULL,\n        plan_code TEXT NOT NULL,\n        status TEXT DEFAULT 'active',\n        start_at DATETIME,\n        end_at DATETIME,\n        renew_type TEXT,\n        provider TEXT,\n        last_sync_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        FOREIGN KEY (user_id) REFERENCES users (id)\n      )`,\n\n      // Usage events table\n      `CREATE TABLE IF NOT EXISTS usage_events (\n        id TEXT PRIMARY KEY,\n        user_id TEXT NOT NULL,\n        type TEXT NOT NULL, -- 'generate' or 'edit'\n        units INTEGER DEFAULT 1,\n        request_id TEXT,\n        metadata TEXT, -- JSON string\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        FOREIGN KEY (user_id) REFERENCES users (id)\n      )`,\n\n      // Usage aggregation table\n      `CREATE TABLE IF NOT EXISTS usage_agg (\n        user_id TEXT NOT NULL,\n        period TEXT NOT NULL, -- YYYYMM format\n        gen_count INTEGER DEFAULT 0,\n        edit_count INTEGER DEFAULT 0,\n        credits_used INTEGER DEFAULT 0,\n        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        PRIMARY KEY (user_id, period),\n        FOREIGN KEY (user_id) REFERENCES users (id)\n      )`,\n\n      // Active requests tracking\n      `CREATE TABLE IF NOT EXISTS active_requests (\n        id TEXT PRIMARY KEY,\n        user_id TEXT NOT NULL,\n        request_id TEXT NOT NULL,\n        type TEXT NOT NULL,\n        started_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        FOREIGN KEY (user_id) REFERENCES users (id)\n      )`,\n\n      // Activation codes table (for global unique activation system)\n      `CREATE TABLE IF NOT EXISTS activation_codes (\n        code TEXT PRIMARY KEY,\n        plan_type INTEGER NOT NULL,\n        credits INTEGER NOT NULL,\n        price DECIMAL(10,2) NOT NULL,\n        status TEXT DEFAULT 'unused',\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        used_at DATETIME NULL,\n        expires_at DATETIME NULL\n      )`,\n\n      // Activations table (device binding)\n      `CREATE TABLE IF NOT EXISTS activations (\n        id TEXT PRIMARY KEY,\n        activation_code TEXT NOT NULL,\n        device_id TEXT NOT NULL,\n        device_info TEXT,\n        user_identifier TEXT,\n        credits_granted INTEGER NOT NULL,\n        credits_used INTEGER DEFAULT 0,\n        activated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        last_used_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        FOREIGN KEY (activation_code) REFERENCES activation_codes (code),\n        UNIQUE(activation_code, device_id)\n      )`,\n\n      // Activation usage table\n      `CREATE TABLE IF NOT EXISTS activation_usage (\n        id TEXT PRIMARY KEY,\n        activation_id TEXT NOT NULL,\n        operation_type TEXT NOT NULL,\n        credits_consumed INTEGER DEFAULT 1,\n        request_metadata TEXT,\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        FOREIGN KEY (activation_id) REFERENCES activations (id)\n      )`,\n\n      // Device fingerprints table\n      `CREATE TABLE IF NOT EXISTS device_fingerprints (\n        device_id TEXT PRIMARY KEY,\n        hardware_info TEXT,\n        first_seen_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        last_seen_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        activation_count INTEGER DEFAULT 0\n      )`\n    ];\n\n    // Create tables sequentially to avoid race conditions\n    this.createTablesSequentially(tables, 0);\n  }\n\n  createTablesSequentially(tables, index) {\n    if (index >= tables.length) {\n      // All tables created, now insert default plans\n      setTimeout(() => this.insertDefaultPlans(), 100);\n      return;\n    }\n\n    this.db.run(tables[index], (err) => {\n      if (err) {\n        logger.error(`Error creating table ${index}:`, err);\n      } else {\n        logger.debug(`Table ${index} created or verified`);\n      }\n      // Create next table\n      this.createTablesSequentially(tables, index + 1);\n    });\n  }\n\n  insertDefaultPlans() {\n    const defaultPlans = [\n      {\n        plan_code: 'free',\n        name: 'Free',\n        monthly_credits: 3,\n        features: JSON.stringify({ maxConcurrency: 1 }),\n        concurrency_limit: 1\n      },\n      {\n        plan_code: 'nano-banana-credits',\n        name: 'Experience Pack',\n        monthly_credits: 20,\n        features: JSON.stringify({ maxConcurrency: 2, price: 9.9, currency: 'CNY', interval: 'one-time' }),\n        concurrency_limit: 2\n      },\n      {\n        plan_code: 'lite-plan',\n        name: 'Lite',\n        monthly_credits: 100,\n        features: JSON.stringify({ maxConcurrency: 2 }),\n        concurrency_limit: 2\n      },\n      {\n        plan_code: 'pro-plan',\n        name: 'Pro',\n        monthly_credits: 500,\n        features: JSON.stringify({ maxConcurrency: 5 }),\n        concurrency_limit: 5\n      }\n    ];\n\n    const insertPlan = this.db.prepare(`\n      INSERT OR IGNORE INTO plan_catalog (plan_code, name, monthly_credits, features, concurrency_limit)\n      VALUES (?, ?, ?, ?, ?)\n    `);\n\n    defaultPlans.forEach(plan => {\n      insertPlan.run([\n        plan.plan_code,\n        plan.name,\n        plan.monthly_credits,\n        plan.features,\n        plan.concurrency_limit\n      ]);\n    });\n\n    insertPlan.finalize();\n  }\n\n  async getUserInfo(userId) {\n    return new Promise((resolve, reject) => {\n      const sql = `\n        SELECT u.*, s.plan_code, s.status as subscription_status, \n               p.monthly_credits, p.concurrency_limit\n        FROM users u\n        LEFT JOIN subscriptions s ON u.id = s.user_id AND s.status = 'active'\n        LEFT JOIN plan_catalog p ON s.plan_code = p.plan_code\n        WHERE u.casdoor_user_id = ?\n      `;\n\n      this.db.get(sql, [userId], (err, row) => {\n        if (err) {\n          reject(err);\n        } else if (row) {\n          resolve({\n            ...row,\n            plan: row.plan_code || 'free',\n            monthlyCredits: row.monthly_credits || 3,\n            maxConcurrency: row.concurrency_limit || 1\n          });\n        } else {\n          // Create user if not exists\n          this.createUser(userId).then(resolve).catch(reject);\n        }\n      });\n    });\n  }\n\n  async createUser(casdoorUserId, email = null, nickname = null) {\n    return new Promise((resolve, reject) => {\n      const userId = require('uuid').v4();\n      const sql = `\n        INSERT INTO users (id, casdoor_user_id, email, nickname)\n        VALUES (?, ?, ?, ?)\n      `;\n\n      this.db.run(sql, [userId, casdoorUserId, email, nickname], function(err) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve({\n            id: userId,\n            casdoor_user_id: casdoorUserId,\n            email,\n            nickname,\n            plan: 'free',\n            monthlyCredits: 3,\n            maxConcurrency: 1\n          });\n        }\n      });\n    });\n  }\n\n  async upsertUser({ id, email, displayName, avatar }) {\n    return new Promise((resolve, reject) => {\n      const sql = `\n        INSERT INTO users (id, casdoor_user_id, email, nickname)\n        VALUES (?, ?, ?, ?)\n        ON CONFLICT(casdoor_user_id) DO UPDATE SET\n          email = excluded.email,\n          nickname = excluded.nickname,\n          updated_at = CURRENT_TIMESTAMP\n      `;\n\n      this.db.run(sql, [require('uuid').v4(), id, email, displayName], function(err) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve({\n            id: id,\n            email,\n            displayName,\n            avatar\n          });\n        }\n      });\n    });\n  }\n\n  async getUserUsage(userId) {\n    return new Promise((resolve, reject) => {\n      const currentPeriod = new Date().toISOString().slice(0, 7).replace('-', ''); // YYYYMM\n      \n      const sql = `\n        SELECT * FROM usage_agg \n        WHERE user_id = (SELECT id FROM users WHERE casdoor_user_id = ?) \n        AND period = ?\n      `;\n\n      this.db.get(sql, [userId, currentPeriod], (err, row) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(row || {\n            genCount: 0,\n            editCount: 0,\n            creditsUsed: 0\n          });\n        }\n      });\n    });\n  }\n\n  async recordUsage({ userId, type, units = 1, requestId, metadata = {} }) {\n    return new Promise((resolve, reject) => {\n      const eventId = require('uuid').v4();\n      const currentPeriod = new Date().toISOString().slice(0, 7).replace('-', ''); // YYYYMM\n\n      this.db.serialize(() => {\n        // Insert usage event\n        const insertEvent = `\n          INSERT INTO usage_events (id, user_id, type, units, request_id, metadata)\n          SELECT ?, u.id, ?, ?, ?, ?\n          FROM users u WHERE u.casdoor_user_id = ?\n        `;\n\n        this.db.run(insertEvent, [\n          eventId, type, units, requestId, JSON.stringify(metadata), userId\n        ], (err) => {\n          if (err) {\n            return reject(err);\n          }\n\n          // Update usage aggregation\n          const updateAgg = `\n            INSERT INTO usage_agg (user_id, period, gen_count, edit_count, credits_used)\n            SELECT u.id, ?, \n                   CASE WHEN ? = 'generate' THEN ? ELSE 0 END,\n                   CASE WHEN ? = 'edit' THEN ? ELSE 0 END,\n                   ?\n            FROM users u WHERE u.casdoor_user_id = ?\n            ON CONFLICT(user_id, period) DO UPDATE SET\n              gen_count = gen_count + CASE WHEN ? = 'generate' THEN ? ELSE 0 END,\n              edit_count = edit_count + CASE WHEN ? = 'edit' THEN ? ELSE 0 END,\n              credits_used = credits_used + ?,\n              updated_at = CURRENT_TIMESTAMP\n          `;\n\n          this.db.run(updateAgg, [\n            currentPeriod, type, units, type, units, units, userId,\n            type, units, type, units, units\n          ], (err) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve({ eventId, period: currentPeriod });\n            }\n          });\n        });\n      });\n    });\n  }\n\n  async getActiveRequests(userId) {\n    return new Promise((resolve, reject) => {\n      const sql = `\n        SELECT COUNT(*) as count\n        FROM active_requests ar\n        JOIN users u ON ar.user_id = u.id\n        WHERE u.casdoor_user_id = ?\n      `;\n\n      this.db.get(sql, [userId], (err, row) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(row.count || 0);\n        }\n      });\n    });\n  }\n\n  // Activation code management methods\n  async createActivationCode({ code, planType, credits, price, expiresAt = null }) {\n    return new Promise((resolve, reject) => {\n      const sql = `\n        INSERT INTO activation_codes (code, plan_type, credits, price, expires_at)\n        VALUES (?, ?, ?, ?, ?)\n      `;\n\n      this.db.run(sql, [code, planType, credits, price, expiresAt], function(err) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve({ code, planType, credits, price });\n        }\n      });\n    });\n  }\n\n  async getActivationCode(code) {\n    return new Promise((resolve, reject) => {\n      const sql = `\n        SELECT * FROM activation_codes WHERE code = ?\n      `;\n\n      this.db.get(sql, [code], (err, row) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(row);\n        }\n      });\n    });\n  }\n\n  async markActivationCodeUsed(code) {\n    return new Promise((resolve, reject) => {\n      const sql = `\n        UPDATE activation_codes\n        SET status = 'used', used_at = CURRENT_TIMESTAMP\n        WHERE code = ?\n      `;\n\n      this.db.run(sql, [code], function(err) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(this.changes > 0);\n        }\n      });\n    });\n  }\n\n  // Device activation management\n  async createActivation({ activationCode, deviceId, deviceInfo, creditsGranted, userIdentifier = null }) {\n    return new Promise((resolve, reject) => {\n      const activationId = require('uuid').v4();\n      const sql = `\n        INSERT INTO activations (id, activation_code, device_id, device_info, user_identifier, credits_granted)\n        VALUES (?, ?, ?, ?, ?, ?)\n      `;\n\n      this.db.run(sql, [activationId, activationCode, deviceId, JSON.stringify(deviceInfo), userIdentifier, creditsGranted], function(err) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve({\n            id: activationId,\n            activationCode,\n            deviceId,\n            creditsGranted,\n            creditsUsed: 0,\n            creditsRemaining: creditsGranted\n          });\n        }\n      });\n    });\n  }\n\n  async getActivation(activationCode, deviceId) {\n    return new Promise((resolve, reject) => {\n      const sql = `\n        SELECT * FROM activations\n        WHERE activation_code = ? AND device_id = ?\n      `;\n\n      this.db.get(sql, [activationCode, deviceId], (err, row) => {\n        if (err) {\n          reject(err);\n        } else {\n          if (row) {\n            resolve({\n              ...row,\n              creditsRemaining: row.credits_granted - row.credits_used,\n              deviceInfo: JSON.parse(row.device_info || '{}')\n            });\n          } else {\n            resolve(null);\n          }\n        }\n      });\n    });\n  }\n\n  async getActivationById(activationId) {\n    return new Promise((resolve, reject) => {\n      const sql = `\n        SELECT a.*, ac.plan_type, ac.credits as total_credits, ac.price\n        FROM activations a\n        JOIN activation_codes ac ON a.activation_code = ac.code\n        WHERE a.id = ?\n      `;\n\n      this.db.get(sql, [activationId], (err, row) => {\n        if (err) {\n          reject(err);\n        } else {\n          if (row) {\n            resolve({\n              ...row,\n              creditsRemaining: row.credits_granted - row.credits_used,\n              deviceInfo: JSON.parse(row.device_info || '{}')\n            });\n          } else {\n            resolve(null);\n          }\n        }\n      });\n    });\n  }\n\n  async updateActivationUsage(activationId, creditsConsumed) {\n    return new Promise((resolve, reject) => {\n      const sql = `\n        UPDATE activations\n        SET credits_used = credits_used + ?, last_used_at = CURRENT_TIMESTAMP\n        WHERE id = ?\n      `;\n\n      this.db.run(sql, [creditsConsumed, activationId], function(err) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(this.changes > 0);\n        }\n      });\n    });\n  }\n\n  async recordActivationUsage({ activationId, operationType, creditsConsumed = 1, requestMetadata = {} }) {\n    return new Promise((resolve, reject) => {\n      const usageId = require('uuid').v4();\n      const sql = `\n        INSERT INTO activation_usage (id, activation_id, operation_type, credits_consumed, request_metadata)\n        VALUES (?, ?, ?, ?, ?)\n      `;\n\n      this.db.run(sql, [usageId, activationId, operationType, creditsConsumed, JSON.stringify(requestMetadata)], function(err) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve({ id: usageId, activationId, operationType, creditsConsumed });\n        }\n      });\n    });\n  }\n\n  // Device fingerprint management\n  async upsertDeviceFingerprint(deviceId, hardwareInfo) {\n    return new Promise((resolve, reject) => {\n      const sql = `\n        INSERT INTO device_fingerprints (device_id, hardware_info, activation_count)\n        VALUES (?, ?, 1)\n        ON CONFLICT(device_id) DO UPDATE SET\n          hardware_info = excluded.hardware_info,\n          last_seen_at = CURRENT_TIMESTAMP,\n          activation_count = activation_count + 1\n      `;\n\n      this.db.run(sql, [deviceId, JSON.stringify(hardwareInfo)], function(err) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve({ deviceId, activationCount: this.changes });\n        }\n      });\n    });\n  }\n\n  async getUserSubscription(userId) {\n    return new Promise((resolve, reject) => {\n      const sql = `\n        SELECT s.*, p.name as plan_name, p.monthly_credits, p.features\n        FROM subscriptions s\n        JOIN users u ON s.user_id = u.id\n        JOIN plan_catalog p ON s.plan_code = p.plan_code\n        WHERE u.casdoor_user_id = ? AND s.status = 'active'\n        ORDER BY s.created_at DESC\n        LIMIT 1\n      `;\n\n      this.db.get(sql, [userId], (err, row) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(row || {\n            plan_code: 'free',\n            plan_name: 'Free',\n            status: 'active',\n            monthly_credits: 3\n          });\n        }\n      });\n    });\n  }\n\n  async createSubscription({ userId, planCode, paymentId, startAt, endAt, provider = 'casdoor' }) {\n    return new Promise((resolve, reject) => {\n      const subscriptionId = require('uuid').v4();\n\n      // First get the user's internal ID\n      const getUserIdSql = `SELECT id FROM users WHERE casdoor_user_id = ?`;\n\n      this.db.get(getUserIdSql, [userId], (err, userRow) => {\n        if (err) {\n          return reject(err);\n        }\n\n        if (!userRow) {\n          return reject(new Error('User not found'));\n        }\n\n        // Deactivate existing subscriptions\n        const deactivateSql = `UPDATE subscriptions SET status = 'expired' WHERE user_id = ? AND status = 'active'`;\n\n        this.db.run(deactivateSql, [userRow.id], (err) => {\n          if (err) {\n            return reject(err);\n          }\n\n          // Create new subscription\n          const insertSql = `\n            INSERT INTO subscriptions (id, user_id, plan_code, status, start_at, end_at, provider, created_at)\n            VALUES (?, ?, ?, 'active', ?, ?, ?, CURRENT_TIMESTAMP)\n          `;\n\n          this.db.run(insertSql, [\n            subscriptionId, userRow.id, planCode, startAt, endAt, provider\n          ], function(err) {\n            if (err) {\n              reject(err);\n            } else {\n              resolve({\n                id: subscriptionId,\n                user_id: userRow.id,\n                plan_code: planCode,\n                status: 'active',\n                start_at: startAt,\n                end_at: endAt,\n                provider\n              });\n            }\n          });\n        });\n      });\n    });\n  }\n\n  async activateSubscription(userId, planCode, paymentData = {}) {\n    try {\n      // Calculate subscription period based on plan\n      const now = new Date();\n      let endDate;\n\n      if (planCode === 'nano-banana-credits') {\n        // One-time purchase, no expiration\n        endDate = new Date('2099-12-31');\n      } else {\n        // Monthly subscription\n        endDate = new Date(now);\n        endDate.setMonth(endDate.getMonth() + 1);\n      }\n\n      const subscription = await this.createSubscription({\n        userId,\n        planCode,\n        paymentId: paymentData.paymentId || null,\n        startAt: now.toISOString(),\n        endAt: endDate.toISOString(),\n        provider: paymentData.provider || 'casdoor'\n      });\n\n      // Reset usage for the new subscription period\n      await this.resetUserUsage(userId);\n\n      return subscription;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async resetUserUsage(userId) {\n    return new Promise((resolve, reject) => {\n      const currentPeriod = new Date().toISOString().slice(0, 7).replace('-', ''); // YYYYMM\n\n      // Delete current period usage\n      const deleteSql = `\n        DELETE FROM usage_agg\n        WHERE user_id = (SELECT id FROM users WHERE casdoor_user_id = ?)\n        AND period = ?\n      `;\n\n      this.db.run(deleteSql, [userId, currentPeriod], (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n  async syncSubscriptionFromCasdoor(userId, casdoorSubscriptionData) {\n    try {\n      const { plan, status, startTime, endTime } = casdoorSubscriptionData;\n\n      if (status === 'Active') {\n        await this.createSubscription({\n          userId,\n          planCode: plan,\n          paymentId: null,\n          startAt: startTime,\n          endAt: endTime,\n          provider: 'casdoor'\n        });\n      }\n\n      return true;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async getExpiredSubscriptions() {\n    return new Promise((resolve, reject) => {\n      const sql = `\n        SELECT s.*, u.casdoor_user_id\n        FROM subscriptions s\n        JOIN users u ON s.user_id = u.id\n        WHERE s.status = 'active' AND s.end_at < datetime('now')\n      `;\n\n      this.db.all(sql, [], (err, rows) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(rows || []);\n        }\n      });\n    });\n  }\n\n  async expireSubscription(subscriptionId) {\n    return new Promise((resolve, reject) => {\n      const sql = `UPDATE subscriptions SET status = 'expired' WHERE id = ?`;\n\n      this.db.run(sql, [subscriptionId], function(err) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(this.changes > 0);\n        }\n      });\n    });\n  }\n\n  close() {\n    if (this.db) {\n      this.db.close((err) => {\n        if (err) {\n          logger.error('Error closing database:', err);\n        } else {\n          logger.info('Database connection closed');\n        }\n      });\n    }\n  }\n}\n\nmodule.exports = new DatabaseService();\n"